# 심화과제: React SSR & SSG

## 🎯 과제 개요
React 프로젝트에서 **Server Side Rendering(SSR)**과 **Static Site Generation(SSG)**을 구현하여, React의 컴포넌트 기반 아키텍처에서도 초기 로딩 성능 최적화와 SEO 향상을 달성합니다.

## 📋 구현해야 할 기능

### 1. React SSR (Server Side Rendering)
- React `renderToString`을 활용한 서버 렌더링
- React Router 서버 환경 지원
- React 상태관리 서버 초기화
- 서버/클라이언트 하이드레이션 처리

### 2. React SSG (Static Site Generation)
- React 컴포넌트를 정적 HTML로 빌드 타임 생성
- TypeScript 지원 및 빌드 파이프라인 구성
- React Suspense 및 비동기 컴포넌트 처리

### 3. 유니버설 React 코드
- 서버/클라이언트 동일 코드 실행
- 브라우저 API 안전 처리
- React Hook 서버 안전성 보장

## 📁 구현해야 할 파일 구조

```
packages/react/
├── server.js                    # Express React SSR 서버  
├── static-site-generate.js      # React SSG 빌드 스크립트
├── src/
│   ├── main-server.tsx         # React SSR 엔트리포인트
│   ├── services/
│   │   ├── ssr-data.ts         # 서버 데이터 로딩 로직
│   │   └── hydration.ts        # 클라이언트 하이드레이션
│   ├── router/
│   │   └── router.ts           # 유니버설 React Router
│   └── App.tsx                 # 메인 React 컴포넌트
├── vite.config.ts              # SSR 빌드 설정
└── package.json                # TypeScript & React 빌드 스크립트
```

## 🔧 1단계: React SSR 서버 구축

### `server.js` 구현
```javascript
import fs from "node:fs/promises";
import express from "express";

// Constants
const prod = process.env.NODE_ENV === "production";
const port = process.env.PORT || 5174; // React용 포트 (vanilla과 구분)
const base = process.env.BASE || (prod ? "/front_6th_chapter4-1/react/" : "/");

// Cached production assets
const templateHtml = prod ? await fs.readFile("../../dist/react/index.html", "utf-8") : "";
const app = express();

// Add Vite or respective production middlewares
let vite;
if (!prod) {
  // TODO: Vite 개발 서버 설정
  // 힌트: createServer로 미들웨어 모드 설정, React 환경에 최적화
} else {
  // TODO: 프로덕션 환경 설정  
  // 힌트: compression, sirv로 React 빌드 파일 서빙
}

// Root redirect for convenience
if (prod && base !== "/") {
  // TODO: 루트 경로 리다이렉트 처리
}

// Serve HTML
app.use(async (req, res) => {
  try {
    const url = req.originalUrl;
    const query = req.query;

    let template;
    let render;
    if (!prod) {
      // TODO: 개발 환경에서 React SSR 모듈 로드
      // 힌트:
      // 1. index.html 템플릿 읽기
      // 2. vite.transformIndexHtml 적용
      // 3. /src/main-server.tsx 모듈 로드
    } else {
      // TODO: 프로덕션 환경에서 빌드된 React SSR 모듈 로드
      // 힌트: 컴파일된 .js 파일 import
    }

    // TODO: React render 함수 호출
    // 힌트: url과 query를 매개변수로 전달

    // TODO: React 하이드레이션을 위한 초기 데이터 주입
    // 힌트: window.__INITIAL_DATA__에 rendered.initialData 할당

    // TODO: 템플릿에 React 렌더링 결과 삽입
    // 힌트: <!--app-html-->에 React 컴포넌트 HTML 삽입

    res.status(200).set({ "Content-Type": "text/html" }).send(html);
  } catch (e) {
    vite?.ssrFixStacktrace(e);
    console.log(e.stack);
    res.status(500).end(e.stack);
  }
});

// Start http server
app.listen(port, () => {
  console.log(`React Server started at http://localhost:${port}`);
});
```

**구현 체크포인트:**
- [ ] React 개발/프로덕션 환경별 설정
- [ ] TypeScript SSR 모듈 로드
- [ ] React 렌더링 결과 템플릿 삽입
- [ ] 에러 처리 및 스택 트레이스

## 🔧 2단계: React SSR 렌더링 로직

### `src/main-server.tsx` 구현
```typescript
import { renderToString } from "react-dom/server";
import { App } from "./App";
import { router } from "./router";
import { loadHomePageData, loadProductDetailData } from "./services/ssr-data";
import { PRODUCT_ACTIONS, productStore } from "./entities";
import { HomePage, ProductDetailPage } from "./pages";
import type { QueryPayload } from "@hanghae-plus/lib";

export const render = async (url: string, query: QueryPayload) => {
  try {
    // TODO: React Router 서버 초기화
    // 힌트:
    // 1. router.push(url)로 현재 URL 설정
    // 2. router.query에 query 할당

    // TODO: URL 패턴에 따른 데이터 프리로딩
    let initialData: any = {};

    if (router.target === HomePage) {
      // TODO: 홈페이지 데이터 로드
      // 힌트:
      // 1. loadHomePageData(url) 호출
      // 2. 성공시 initialData에 할당
      // 3. productStore.dispatch로 SETUP 액션 호출
      // 4. products, categories, totalCount 설정
      
    } else if (router.target === ProductDetailPage) {
      // TODO: 상품 상세 페이지 데이터 로드
      // 힌트:
      // 1. router.params.id로 상품 ID 추출
      // 2. loadProductDetailData(productId) 호출
      // 3. SET_CURRENT_PRODUCT 액션 호출
      // 4. relatedProducts가 있으면 SET_RELATED_PRODUCTS 호출
    }

    // TODO: React 컴포넌트를 HTML 문자열로 렌더링
    // 힌트: renderToString(<App />) 사용

    return {
      html,
      head: `<title>React Shopping App</title>`,
      initialData,
    };
  } catch (error) {
    const err = error as Error;
    console.error("React SSR 렌더링 오류:", error);
    
    return {
      html: `<div>페이지를 불러오는 중 오류가 발생했습니다: ${err.message}</div>`,
      head: `<title>React Shopping App</title>`,
      initialData: {},
    };
  }
};
```

**구현 체크포인트:**
- [ ] React Router 서버 초기화
- [ ] 페이지별 데이터 프리로딩
- [ ] React 상태관리 서버 설정
- [ ] renderToString React 컴포넌트 렌더링

## 🔧 3단계: 서버 데이터 로딩 서비스

### `src/services/ssr-data.ts` 구현
```typescript
import { Router } from "@hanghae-plus/lib";
import { mockGetProducts, mockGetCategories, mockGetProduct } from "../mocks/server.js";

export interface HomePageData {
  products: any[];
  categories: any[];
  totalCount: number;
}

export interface ProductDetailData {
  currentProduct: any;
  relatedProducts?: any[];
}

export async function loadHomePageData(url: string): Promise<HomePageData | null> {
  try {
    // TODO: URL에서 query 파라미터 추출
    // 힌트: Router.parseQuery와 URL 객체 사용
    
    // TODO: 상품 목록 및 카테고리 데이터 로드
    // 힌트:
    // 1. mockGetProducts(query) 호출
    // 2. mockGetCategories() 호출  
    // 3. HomePageData 인터페이스에 맞게 반환

    return {
      products: productsData.products,
      categories,
      totalCount: productsData.pagination.total,
    };
  } catch (error) {
    console.error("홈페이지 데이터 로드 실패:", error);
    return null;
  }
}

export async function loadProductDetailData(productId: string): Promise<ProductDetailData | null> {
  try {
    // TODO: 상품 상세 정보 로드
    // 힌트: mockGetProduct(productId) 호출
    
    // TODO: 관련 상품 로드
    let relatedProducts = [];
    if (product.category2) {
      try {
        // 힌트:
        // 1. product.category2로 같은 카테고리 상품 검색
        // 2. mockGetProducts 호출 (category2, limit, page 매개변수)
        // 3. 현재 상품 제외 필터링
      } catch (error) {
        console.error("관련 상품 로드 실패:", error);
      }
    }

    return {
      currentProduct: product,
      relatedProducts,
    };
  } catch (error) {
    console.error("상품 상세 데이터 로드 실패:", error);
    return null;
  }
}
```

**구현 체크포인트:**
- [ ] URL 쿼리 파라미터 추출
- [ ] Mock 데이터 API 호출
- [ ] TypeScript 인터페이스 준수
- [ ] 에러 처리 및 null 반환

## 🔧 4단계: React 클라이언트 하이드레이션

### `src/services/hydration.ts` 구현
```typescript
import { productStore, PRODUCT_ACTIONS } from "../entities";

export function hydrateFromServerData() {
  // TODO: 서버에서 전달된 초기 데이터 확인
  if (typeof window !== "undefined" && window.__INITIAL_DATA__) {
    const initialData = (window as any).__INITIAL_DATA__;
    
    try {
      if (initialData.products && initialData.categories) {
        // TODO: 홈페이지 데이터 복원
        // 힌트:
        // 1. PRODUCT_ACTIONS.SETUP 액션 호출
        // 2. products, categories, totalCount 설정
        // 3. loading: false, status: "done" 설정
      }
      
      if (initialData.currentProduct) {
        // TODO: 상품 상세 데이터 복원
        // 힌트:
        // 1. SET_CURRENT_PRODUCT 액션 호출
        // 2. relatedProducts가 있으면 SET_RELATED_PRODUCTS 액션 호출
      }
      
      console.log("✅ 서버 데이터 하이드레이션 완료");
    } catch (error) {
      console.error("❌ 하이드레이션 오류:", error);
    }
    
    // TODO: 초기 데이터 정리
    // 힌트: delete (window as any).__INITIAL_DATA__
  }
}
```

### `src/main.tsx` 수정 (클라이언트 엔트리포인트)
```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import { App } from "./App";
import { hydrateFromServerData } from "./services/hydration";

// TODO: 서버 데이터 하이드레이션
// 힌트: hydrateFromServerData() 함수 호출

const container = document.getElementById("root");
if (!container) throw new Error("Root container not found");

// TODO: React 18 방식으로 루트 생성 및 렌더링
// 힌트:
// 1. createRoot(container) 사용
// 2. root.render()로 <App /> 렌더링
// 3. StrictMode로 감싸기
```

**구현 체크포인트:**
- [ ] 서버 데이터 존재 확인
- [ ] React 상태관리에 데이터 복원
- [ ] 메모리 정리
- [ ] React 18 하이드레이션

## 🔧 5단계: 유니버설 React 라우터

### `src/router/router.ts` 확장
```typescript
import { Router, MemoryRouter } from "@hanghae-plus/lib";
import { HomePage, ProductDetailPage, NotFoundPage } from "../pages";

// TODO: 서버/클라이언트 환경에 따른 라우터 선택
const createRouter = () => {
  if (typeof window === "undefined") {
    // TODO: 서버 환경 라우터 설정
    // 힌트: MemoryRouter 사용
  } else {
    // TODO: 브라우저 환경 라우터 설정
    // 힌트: 기존 Router 사용
  }
};

export const router = createRouter();

// TODO: 라우트 설정
// 힌트:
// 1. router.addRoute("/", HomePage)
// 2. router.addRoute("/product/:id/", ProductDetailPage)  
// 3. router.addRoute("*", NotFoundPage)

// TODO: 서버에서 안전하게 라우터 시작
// 힌트: typeof window !== "undefined" 체크 후 router.start()
```

**구현 체크포인트:**
- [ ] 서버/클라이언트 환경 분기
- [ ] MemoryRouter vs Router 선택
- [ ] 라우트 등록
- [ ] 안전한 브라우저 API 사용

## 🔧 6단계: React SSG 구현

### `static-site-generate.js` 구현
```javascript
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// 프로덕션 환경에서 SSG 실행
process.env.NODE_ENV = "production";

const DIST_DIR = path.resolve(__dirname, "../../dist/react");

async function generateStaticSite() {
  try {
    console.log("🚀 React SSG 시작...");
    
    // TODO: 1. 템플릿 HTML 로드
    // 힌트: DIST_DIR의 index.html 읽기

    // TODO: 2. 빌드된 React SSR 모듈 로드
    // 힌트:
    // 1. ./dist/react-ssr/main-server.js import
    // 2. render 함수 존재 확인

    if (!render) {
      throw new Error("React render 함수를 찾을 수 없습니다");
    }

    // TODO: 3. 생성할 페이지 목록 정의
    const pagesToGenerate = await getPages();
    console.log(`📄 ${pagesToGenerate.length}개 React 페이지 생성 시작...`);

    // TODO: 4. 각 페이지별로 React 컴포넌트를 HTML로 변환
    for (const page of pagesToGenerate) {
      try {
        console.log(`🔄 React 컴포넌트 렌더링: ${page.url}`);
        
        // TODO: render 함수로 React 페이지 렌더링
        // 힌트: render(page.url, {}) 호출

        // TODO: 초기 데이터 스크립트 생성
        
        // TODO: 템플릿에 React 렌더링 결과 삽입

        // TODO: HTML 파일 저장
        await saveHtmlFile(page.filePath, html);
        console.log(`✅ React 페이지 생성 완료: ${page.url}`);
      } catch (error) {
        console.error(`❌ React 페이지 ${page.url} 생성 실패:`, error.message);
      }
    }

    console.log(`🎉 React SSG 완료!`);
  } catch (error) {
    console.error("💥 React SSG 실패:", error);
    process.exit(1);
  }
}

async function getPages() {
  const pages = [];
  const baseUrl = process.env.NODE_ENV === "production" ? "/front_6th_chapter4-1/react/" : "/";

  // TODO: 홈페이지 추가
  // 힌트: baseUrl, DIST_DIR/index.html

  // TODO: 404 페이지 추가
  // 힌트: baseUrl + "404", DIST_DIR/404.html

  // TODO: 상품 상세 페이지들 동적 생성
  try {
    // 힌트:
    // 1. ./src/mocks/server.js에서 mockGetProducts import
    // 2. 상품 목록 조회 (limit: 20)
    // 3. 각 상품별로 pages 배열에 추가
    // 4. baseUrl + product/${productId}/, DIST_DIR/product/productId/index.html

    console.log(`🛍️ ${productsData.products.length}개 상품 페이지 추가됨`);
  } catch (error) {
    console.error("상품 목록 로드 실패:", error);
  }

  return pages;
}

async function saveHtmlFile(filePath, html) {
  // TODO: 디렉토리 생성 및 파일 저장
  // 힌트: fs.mkdir, fs.writeFile 사용
}

// 실행
generateStaticSite().catch(console.error);
```

**구현 체크포인트:**
- [ ] 빌드된 React SSR 모듈 로드
- [ ] React 컴포넌트 정적 렌더링
- [ ] 상품별 동적 페이지 생성
- [ ] 파일 시스템 조작

## 🔧 7단계: TypeScript 빌드 설정

### `vite.config.ts` 확장
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      // TODO: SSR 빌드 시 Node.js 환경 최적화
      // 힌트: react-dom/server를 external로 설정
    },
  },
  ssr: {
    // TODO: 서버에서 externalize할 패키지들 설정
    // 힌트: @hanghae-plus/lib를 noExternal로 설정
  },
});
```

### `package.json` 스크립트 설정
```json
{
  "scripts": {
    "dev": "vite",
    "dev:ssr": "node server.js",
    "build:csr": "vite build --outDir ../../dist/react && cp ../../dist/react/index.html ../../dist/react/404.html",
    "build:ssr": "vite build --outDir ./dist/react-ssr --ssr src/main-server.tsx",
    "build:ssg": "node static-site-generate.js",
    "build": "npm run build:csr && npm run build:ssr && npm run build:ssg",
    "preview:ssr": "NODE_ENV=production node server.js",
    "preview:ssg": "NODE_ENV=production vite preview --outDir ../../dist/react",
    "tsc": "tsc --noEmit"
  }
}
```

## 🔧 8단계: React Hook 서버 안전성 확보

### 서버 안전 커스텀 Hook 구현
```typescript
// src/hooks/useIsomorphicEffect.ts
import { useEffect, useLayoutEffect } from "react";

// TODO: 서버/클라이언트 환경별 Effect Hook 선택
// 힌트: typeof window !== "undefined" 체크하여 useLayoutEffect vs useEffect

// src/hooks/useSafeAsync.ts  
import { useEffect, useState } from "react";

export function useSafeAsync<T>(
  asyncFn: () => Promise<T>,
  deps: React.DependencyList
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    // TODO: 서버에서는 비동기 작업 실행하지 않음
    // 힌트:
    // 1. typeof window === "undefined" 체크
    // 2. 서버에서는 setLoading(false) 후 return
    // 3. 클라이언트에서는 asyncFn() 실행
    // 4. Promise 완료 후 상태 업데이트
    // 5. cleanup 함수로 cancelled 플래그 사용
  }, deps);

  return { data, loading, error };
}
```

**구현 체크포인트:**
- [ ] 서버/클라이언트 환경 분기
- [ ] 서버에서 안전한 Hook 동작
- [ ] 비동기 작업 취소 처리
- [ ] TypeScript 제네릭 타입 지원

## ✅ 구현 가이드라인

### 🎯 React 특화 구현 포인트

**1. React SSR 렌더링**
- `renderToString`으로 React 컴포넌트를 HTML 문자열 변환
- React Router 서버 환경 초기화
- React 상태관리 서버 초기값 설정

**2. React 하이드레이션**
- 서버 렌더링된 HTML과 클라이언트 React 컴포넌트 매칭
- 초기 상태 복원으로 하이드레이션 에러 방지
- React 18 createRoot 사용

**3. 유니버설 React 코드**
- 서버에서는 MemoryRouter, 클라이언트에서는 BrowserRouter
- typeof window 체크로 브라우저 API 안전 사용
- React Hook 서버 안전성 확보

### 🔍 React 디버깅 힌트

**하이드레이션 불일치:**
- 서버/클라이언트 초기 상태 동일성 확인
- 조건부 렌더링에서 서버/클라이언트 차이점 확인
- React DevTools에서 하이드레이션 경고 확인

**React Router 문제:**
- MemoryRouter 초기 URL 설정 확인
- 서버에서 router.push() 호출 순서 확인
- 라우트 매개변수 추출 로직 검증

**React 상태관리 문제:**
- 서버에서 store 초기화 확인
- 하이드레이션 시 상태 복원 순서 확인
- Redux/Zustand 서버 호환성 확인

### 📋 단계별 테스트

**React SSR 테스트:**
```bash
npm run dev:ssr
# React 컴포넌트가 서버에서 렌더링되는지 확인
# 브라우저에서 "View Page Source"로 React HTML 확인
```

**React 하이드레이션 테스트:**
```bash
# DevTools Console에서 하이드레이션 에러 확인
# Network 탭에서 불필요한 재요청 없는지 확인
```

**React SSG 테스트:**
```bash
npm run build
# dist/react 디렉토리의 정적 HTML 파일 확인
# 각 HTML에 React 컴포넌트 렌더링 결과 포함 확인
```

**통합 테스트:**
```bash
npm run preview:ssr
npm run preview:ssg
# SSR과 SSG 결과물 동일성 확인
# React 컴포넌트 상호작용 정상 동작 확인
```

## 🎯 React 특화 학습 목표

1. **React SSR 아키텍처**: `renderToString`을 활용한 컴포넌트 서버 렌더링
2. **React 하이드레이션**: 서버 렌더링된 React 컴포넌트를 클라이언트에서 활성화
3. **유니버설 React**: 서버/클라이언트에서 동일하게 실행되는 React 코드 작성
4. **React Hook 서버 안전성**: `useEffect`, `useState` 등이 서버에서 안전하게 동작하도록 처리
5. **React Router SSR**: 클라이언트 라우팅을 서버에서도 동일하게 처리
6. **React 상태관리 SSR**: Redux, Zustand 등 상태관리 라이브러리의 서버 지원
7. **TypeScript SSR**: TypeScript 기반 React SSR 빌드 파이프라인 구축

## 📚 참고사항

- React SSR 가이드: https://react.dev/reference/react-dom/server
- Vite React SSR: https://vitejs.dev/guide/ssr.html#generating-preload-directives
- React renderToString: https://react.dev/reference/react-dom/server/renderToString
- React Hydration: https://react.dev/reference/react-dom/client/hydrateRoot
