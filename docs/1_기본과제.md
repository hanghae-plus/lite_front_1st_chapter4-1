# 기본과제: Vanilla JavaScript SSR & SSG

## 🎯 과제 개요
Vanilla JavaScript 프로젝트에서 **Server Side Rendering(SSR)**과 **Static Site Generation(SSG)**을 구현하여, 기존 CSR 방식에서 발생하는 초기 로딩 지연과 SEO 문제를 해결합니다.

## 📋 구현해야 할 기능

### 1. SSR (Server Side Rendering)
- Express 서버를 통한 서버사이드 렌더링
- URL별 라우팅 및 매개변수 추출
- 서버에서 데이터 프리페칭
- 초기 데이터 Hydration

### 2. SSG (Static Site Generation)
- 빌드 타임에 정적 HTML 파일 생성
- 동적 라우트 (상품 상세 페이지) 처리
- SEO 최적화된 메타 태그 생성

## 📁 구현해야 할 파일 구조

```
packages/vanilla/
├── server.js                 # Express SSR 서버
├── static-site-generate.js   # SSG 빌드 스크립트
├── src/
│   ├── main-server.js       # 서버 렌더링 로직
│   ├── lib/
│   │   └── Router.js        # 서버용 라우터 확장
│   └── pages/
│       ├── HomePage.js
│       ├── ProductDetailPage.js
│       └── NotFoundPage.js
└── package.json             # 빌드 스크립트 추가
```

## 🔧 1단계: Express SSR 서버 구축

### `server.js` 구현
```javascript
import fs from "node:fs/promises";
import express from "express";

// Constants
const prod = process.env.NODE_ENV === "production";
const port = process.env.PORT || 5173;
const base = process.env.BASE || (prod ? "/front_6th_chapter4-1/vanilla/" : "/");

// Cached production assets
const templateHtml = prod ? await fs.readFile("../../dist/vanilla/index.html", "utf-8") : "";
const app = express();

// Add Vite or respective production middlewares
let vite;
if (!prod) {
  // TODO: Vite 개발 서버 설정
  // 힌트: createServer로 미들웨어 모드 설정, middlewares 사용
} else {
  // TODO: 프로덕션 환경 설정
  // 힌트: compression, sirv 사용하여 정적 파일 서빙
}

// Root redirect for convenience
if (prod && base !== "/") {
  // TODO: 루트 경로에서 base URL로 리다이렉트 구현
}

// Serve HTML
app.use("*", async (req, res) => {
  try {
    console.log("🔍 Request URL:", req.originalUrl);
    const url = req.originalUrl.replace(base, "");

    let template;
    let render;
    if (!prod) {
      // TODO: 개발 환경에서 템플릿 읽기 및 SSR 모듈 로드
      // 힌트: 
      // 1. index.html 읽기
      // 2. vite.transformIndexHtml 사용
      // 3. vite.ssrLoadModule로 main-server.js 로드
    } else {
      // TODO: 프로덕션 환경에서 캐시된 템플릿 및 빌드된 SSR 모듈 사용
      // 힌트: templateHtml 사용, import로 빌드된 모듈 로드
    }

    // TODO: render 함수 호출하여 페이지 렌더링
    const rendered = await render(url);

    // TODO: 서버 데이터를 클라이언트로 전달하기 위한 스크립트 생성
    // 힌트: window.__INITIAL_DATA__에 initialData 할당하는 script 태그 생성

    // TODO: 템플릿에 렌더링 결과 삽입
    // 힌트: 
    // 1. <!--app-head--> → rendered.head
    // 2. <!--app-html--> → rendered.html  
    // 3. </head> → initialDataScript + </head>

    res.status(200).set({ "Content-Type": "text/html" }).send(html);
  } catch (e) {
    vite?.ssrFixStacktrace(e);
    console.log(e.stack);
    res.status(500).end(e.stack);
  }
});

// Start http server
app.listen(port, () => {
  console.log(`Server started at http://localhost:${port}`);
});
```

**구현 체크포인트:**
- [ ] 개발/프로덕션 환경에 따른 미들웨어 설정
- [ ] SSR 모듈 동적 로드
- [ ] 템플릿 치환 로직
- [ ] 초기 데이터 주입 스크립트 생성

## 🔧 2단계: 서버 렌더링 로직 구현

### `src/main-server.js` 구현
```javascript
import { Router } from "./lib/Router.js";
import { HomePage, NotFoundPage, ProductDetailPage } from "./pages/index.js";
import { BASE_URL } from "./constants.js";
import { mockGetProducts, mockGetCategories, mockGetProduct } from "./mocks/server.js";
import { productStore, PRODUCT_ACTIONS, initialProductState } from "./stores/index.js";

class ServerRouter {
  constructor(baseUrl = "") {
    this.routes = new Map();
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.initRoutes();
  }

  initRoutes() {
    // TODO: 라우트 등록
    // 힌트: addRoute 메소드를 사용하여 경로와 핸들러 등록
    // - "/" → HomePage
    // - "/product/:id/" → ProductDetailPage  
    // - "/.*" → NotFoundPage (404 처리)
  }

  addRoute(path, handler) {
    // TODO: 라우트 패턴을 정규식으로 변환
    // 힌트:
    // 1. :id 같은 매개변수를 정규식 그룹으로 변환
    // 2. paramNames 배열에 매개변수 이름 저장
    // 3. 정규식 객체 생성하여 routes Map에 저장
  }

  findRoute(url) {
    // TODO: URL에 매칭되는 라우트 찾기
    // 힌트:
    // 1. URL에서 pathname 추출
    // 2. baseUrl 제거
    // 3. 등록된 라우트들과 매칭 시도
    // 4. 매개변수 추출하여 params 객체 생성
    // 5. 매칭되는 라우트 반환, 없으면 null
  }
}

async function prefetchData(route, query, params) {
  try {
    if (route.path === "/") {
      // TODO: 홈페이지 데이터 프리페칭
      // 힌트:
      // 1. mockGetProducts로 상품 목록 조회
      // 2. mockGetCategories로 카테고리 조회
      // 3. productStore에 데이터 설정
      // 4. 필요한 데이터 반환
      
    } else if (route.path === "/product/:id/") {
      // TODO: 상품 상세 페이지 데이터 프리페칭
      // 힌트:
      // 1. params.id로 상품 ID 추출
      // 2. mockGetProduct로 상품 상세 정보 조회
      // 3. productStore에 currentProduct 설정
      // 4. 관련 상품이 있다면 추가 로드
      // 5. 필요한 데이터 반환
    }
    return null;
  } catch (error) {
    console.error("데이터 프리페칭 오류:", error);
    return null;
  }
}

export async function render(url) {
  try {
    // TODO: Store 초기화
    // 힌트: productStore.dispatch로 초기 상태 설정

    // TODO: ServerRouter 인스턴스 생성 및 라우트 찾기
    // 힌트: 개발/프로덕션 환경에 따른 baseUrl 설정

    console.log("Requested URL:", url);
    console.log("Found route:", route);

    if (!route) {
      // TODO: 404 응답 반환
      // 힌트: NotFoundPage() 호출하여 html 생성
    }

    // TODO: URL에서 query, params 추출
    // 힌트: Router.parseQuery 사용, route.params 사용

    // TODO: 글로벌 라우터 정보 설정
    // 힌트: global.router 객체에 query, params, baseUrl 설정

    // TODO: 서버에서 데이터 미리 로드
    const initialData = await prefetchData(route, query, params);

    // TODO: 페이지별 HTML 및 메타 정보 생성
    // 힌트:
    // 1. route.path에 따라 적절한 페이지 컴포넌트 호출
    // 2. 페이지별 title 설정
    // 3. initialData와 함께 반환

    let pageHtml;
    let pageTitle = "쇼핑몰";

    // TODO: 라우트별 페이지 렌더링 로직 구현

    return {
      html: pageHtml,
      head: `<title>${pageTitle}</title>`,
      initialData,
    };
  } catch (error) {
    console.error("SSR Error:", error);
    return {
      html: "<div>서버 렌더링 중 오류가 발생했습니다.</div>",
      head: "<title>오류 - 쇼핑몰</title>",
      initialData: null,
    };
  }
}
```

**구현 체크포인트:**
- [ ] URL 패턴 매칭 정규식 생성
- [ ] 라우트 매개변수 추출
- [ ] 페이지별 데이터 프리페칭
- [ ] 상태관리 서버 초기화
- [ ] 동적 메타 태그 생성

## 🔧 3단계: SSG 구현

### `static-site-generate.js` 구현
```javascript
import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// NODE_ENV을 development로 설정 (BASE_URL을 빈 문자열로 사용하기 위해)
process.env.NODE_ENV = "development";

const DIST_DIR = path.resolve(__dirname, "../../dist/vanilla");
const SSR_DIR = path.resolve(__dirname, "./dist/vanilla-ssr");

async function generateStaticSite() {
  console.log("🚀 Static Site Generation 시작...");

  try {
    // TODO: 1. 템플릿 HTML 로드
    // 힌트: DIST_DIR의 index.html 읽기

    // TODO: 2. SSR 렌더 함수 로드  
    // 힌트: 
    // 1. SSR_DIR의 main-server.js 경로 생성
    // 2. import()로 동적 로드
    // 3. render 함수 존재 확인

    console.log("⚙️ SSR 모듈 로드 완료");

    // TODO: 3. 생성할 페이지 목록 정의
    const pagesToGenerate = await getPages();
    console.log(`📝 생성할 페이지 수: ${pagesToGenerate.length}`);

    // TODO: 4. 각 페이지별로 HTML 생성
    for (const page of pagesToGenerate) {
      console.log(`📄 생성 중: ${page.url}`);

      try {
        // TODO: render 함수로 페이지 렌더링

        // TODO: 서버 데이터를 클라이언트로 전달하기 위한 스크립트 생성
        // 힌트: rendered.initialData가 있으면 window.__INITIAL_DATA__ 스크립트 생성

        // TODO: 템플릿에 렌더링 결과 삽입
        // 힌트: server.js와 동일한 치환 로직

        // TODO: HTML 파일 저장
        await saveHtmlFile(page.filePath, html);
        console.log(`✅ 생성 완료: ${page.filePath}`);
      } catch (error) {
        console.error(`❌ ${page.url} 생성 실패:`, error.message);
      }
    }

    console.log("🎉 Static Site Generation 완료!");
  } catch (error) {
    console.error("💥 SSG 실패:", error);
    process.exit(1);
  }
}

async function getPages() {
  const pages = [];

  // TODO: 홈페이지 추가
  // 힌트: url: "/", filePath: DIST_DIR/index.html

  // TODO: 404 페이지 추가  
  // 힌트: url: "/404", filePath: DIST_DIR/404.html

  // TODO: 상품 상세 페이지들 추가
  try {
    // 힌트:
    // 1. ./src/mocks/server.js에서 mockGetProducts import
    // 2. 상품 목록 조회 (limit: 20)
    // 3. 각 상품별로 pages 배열에 추가
    // 4. url: `/product/${productId}/`, filePath: DIST_DIR/product/productId/index.html

    console.log(`🛍️ 상품 페이지 ${productsData.products.length}개 추가됨`);
  } catch (error) {
    console.error("상품 목록 로드 실패:", error);
  }

  return pages;
}

async function saveHtmlFile(filePath, html) {
  // TODO: 디렉토리 생성 및 HTML 파일 저장
  // 힌트:
  // 1. path.dirname(filePath)로 디렉토리 경로 추출
  // 2. fs.mkdir로 디렉토리 생성 (recursive: true)
  // 3. fs.writeFile로 HTML 파일 저장
}

// 실행
generateStaticSite().catch(console.error);
```

**구현 체크포인트:**
- [ ] 빌드된 SSR 모듈 동적 로드
- [ ] 페이지 목록 동적 생성
- [ ] 상품 데이터 기반 동적 라우트 생성
- [ ] 디렉토리 구조 생성 및 파일 저장

## 🔧 4단계: 빌드 스크립트 설정

### `package.json` 스크립트 추가
```json
{
  "scripts": {
    "dev": "vite",
    "dev:ssr": "node server.js",
    "build:client": "vite build --outDir ../../dist/vanilla && cp ../../dist/vanilla/index.html ../../dist/vanilla/404.html",
    "build:server": "vite build --outDir ./dist/vanilla-ssr --ssr src/main-server.js",
    "build:ssg": "node static-site-generate.js",
    "build": "pnpm run build:client && pnpm run build:server && pnpm run build:ssg",
    "preview:ssr": "NODE_ENV=production node server.js",
    "preview:ssg": "vite preview --outDir ../../dist/vanilla"
  },
  "dependencies": {
    "compression": "^1.8.1",
    "express": "^5.1.0",
    "sirv": "^3.0.1"
  }
}
```

## 🔧 5단계: 클라이언트 Hydration 처리

### `src/main.js` 수정
```javascript
import { render } from "./render.js";
import { productStore, PRODUCT_ACTIONS, initialProductState } from "./stores/index.js";

// TODO: 서버에서 전달된 초기 데이터 사용
// 힌트:
// 1. window.__INITIAL_DATA__ 확인
// 2. 데이터가 있으면 적절한 액션으로 store에 dispatch
// 3. 홈페이지 데이터: PRODUCT_ACTIONS.SETUP
// 4. 상품 상세 데이터: PRODUCT_ACTIONS.SET_CURRENT_PRODUCT
// 5. 사용 완료 후 window.__INITIAL_DATA__ 삭제

// 클라이언트 렌더링 시작
render();
```

**구현 체크포인트:**
- [ ] 서버 데이터 존재 여부 확인
- [ ] 페이지 타입별 데이터 복원
- [ ] 상태관리 스토어 초기화
- [ ] 메모리 정리

## ✅ 구현 가이드라인

### 🎯 핵심 구현 포인트

**1. 서버 라우터 (ServerRouter)**
- 정규식 기반 URL 패턴 매칭
- 동적 매개변수 추출 (:id → 실제 값)
- 우선순위 기반 라우트 매칭

**2. 데이터 프리페칭 (prefetchData)**
- 페이지별 필요한 데이터 미리 로드
- 서버 상태관리에 데이터 설정
- 클라이언트에 전달할 데이터 구조화

**3. 정적 사이트 생성 (SSG)**
- 빌드된 SSR 모듈 활용
- 동적 라우트 목록 생성
- 파일 시스템 조작

### 🔍 디버깅 힌트

**서버 라우팅 문제:**
- console.log로 URL 매칭 과정 추적
- 정규식 패턴 테스트: `regex.test(pathname)`
- 매개변수 추출 결과 확인

**데이터 로딩 문제:**
- mock 데이터 함수 호출 결과 확인
- 상태관리 액션 dispatch 결과 검증
- initialData 직렬화 가능성 확인

**SSG 빌드 문제:**
- 파일 경로 절대/상대 경로 확인
- import 구문 동적 로드 문법 확인
- 디렉토리 권한 및 존재 여부 확인

### 📋 단계별 테스트

**1단계 테스트:**
```bash
pnpm run dev:ssr
# http://localhost:5173 접속하여 SSR 동작 확인
```

**2단계 테스트:**
```bash
# 브라우저에서 페이지 소스 보기로 서버 렌더링 확인
# Network 탭에서 초기 데이터 확인
```

**3단계 테스트:**
```bash
pnpm run build
# dist 디렉토리에 생성된 HTML 파일들 확인
```

**통합 테스트:**
```bash
pnpm run preview:ssr
pnpm run preview:ssg
# 두 방식 모두 동일한 결과 출력 확인
```

## 🎯 학습 목표

1. **SSR의 동작 원리**: 서버에서 HTML을 렌더링하여 초기 로딩 성능 개선
2. **SSG의 활용법**: 빌드 타임에 정적 HTML 생성으로 최고의 성능 달성
3. **유니버설 JavaScript**: 서버와 클라이언트에서 동일한 코드 실행
4. **Hydration 개념**: 서버 렌더링된 HTML을 클라이언트에서 활성화
5. **라우팅 시스템**: 서버사이드에서의 라우팅 처리 방법

## 📚 참고사항

- Vite SSR 가이드: https://vitejs.dev/guide/ssr.html
- Express.js 공식 문서: https://expressjs.com/
- Node.js File System API: https://nodejs.org/api/fs.html
